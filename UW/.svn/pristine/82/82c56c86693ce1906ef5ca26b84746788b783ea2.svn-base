#!/usr/bin/env python
"""Provide GUI for frequency scan and Rabi flop experiments."""

from time import sleep

import Tkinter as tk
from multiprocessing import Process, Pipe

import numpy as np

import matplotlib.figure as mplfig
import matplotlib.backends.backend_tkagg as tkagg

class App:
    "Provide GUI for frequency scan and Rabi Flop experiments."
    def __init__( self, conn ):
        self.master = tk.Tk()
        self.conn = conn

        self.background = []
        self.occurences, self.shelves = {}, {}
        self.before = [0]*3
        self.after = [0]*3

        self.bright_fig = mplfig.Figure( figsize=(2.5, 6.5) )
        self.before_axes = self.bright_fig.add_axes( [0.1, 0.55, 0.8, 0.4] )
        self.after_axes = self.bright_fig.add_axes( [0.1, 0.05, 0.8, 0.4] )
        self.bright_canvas = tkagg.FigureCanvasTkAgg(
            self.bright_fig, master=self.master )
        self.bright_canvas.get_tk_widget().pack( side=tk.LEFT,
            fill=tk.Y, expand=1 )
        self.before_axes.get_xaxis().set_visible(False)
        self.before_axes.get_yaxis().set_visible(False)
        self.after_axes.get_xaxis().set_visible(False)
        self.after_axes.get_yaxis().set_visible(False)

        self.data_fig = mplfig.Figure( figsize=(6.5, 6.5) )
        self.data_axes = self.data_fig.add_axes( [0.1, 0.1, 0.8, 0.8] )
        self.data_canvas = tkagg.FigureCanvasTkAgg( 
            self.data_fig, master=self.master )
        self.data_canvas.get_tk_widget().pack( side=tk.LEFT,
            fill=tk.BOTH, expand=1 )
        self.data_axes.grid( True )

        self.plot()

        self.tick()
        self.master.mainloop()

    def tick( self ):
        "Check for new data from interprocess conn."
        if self.conn.poll():
            new_data = self.conn.recv().split()
            time = float( new_data[0] )
            nions = (len( new_data ) - 3) / 2
            self.background.append( float(new_data[ nions+1 ]) )
            self.background.append( float(new_data[ nions*2+2 ]) )
            if len(self.background) > 1000:
                self.background = self.background[100:]

            bkg = np.mean( self.background )
            thresh = 3*np.std( self.background )

            self.before = np.array( new_data[1:nions+1], dtype=float )
            self.after = np.array( new_data[nions+2:2*nions+2], dtype=float )

            before_ions = self.before - bkg > thresh
            after_ions = self.after - bkg > thresh

            if not self.occurences.has_key( time ):
                self.occurences[ time ] = [0]*nions
                self.shelves[ time ] = [0]*nions

            for i in range( nions ):
                if before_ions[i]:
                    self.occurences[time][i] += 1
                if before_ions[i] and not after_ions[i]:
                    self.shelves[time][i] += 1
            self.plot()
        self.master.after( 500, self.tick )

    def plot( self ):
        "Update data plots from new data."
        self.before_axes.bar( np.arange(len(self.before)), self.before )
        self.after_axes.bar( np.arange(len(self.after)), self.after )
        self.before_axes.set_ylim( 800000, 830000 )
        self.after_axes.set_ylim( 800000, 830000 )
        self.bright_canvas.draw()

        keys = list( sorted(self.occurences.keys()) )
        vals = [[ float(s) / o if o else 0
            for s, o in zip( self.occurences[t], self.shelves[t] )]
            for t in keys ]
        print( keys, vals )
        colors = ['r', 'g', 'b', 'c']
        if vals:
            for i in range( len(vals[0]) ):
                self.data_axes.plot( keys, [v[i] for v in vals], colors[i] )
        self.data_canvas.draw()


def experiment( conn ):
    "Run experiment and route incoming data to conn."
    #from freqscan import Experiment
    #Experiment( 200, 86.3, 85.8, 0.01, 500, 'ion_positions.txt', i
    #    'test.txt', conn )
    sleep( 2 )
    i = 0
    while i < 10:
        i += 1
        dat = "12 815000 803000 816000 803500 814500 802500 802000 803000" 
        conn.send( dat )
        sleep(1)
    while i < 20:
        i += 1
        dat = "15 815000 803000 816000 803500 814500 802500 802000 803000" 
        conn.send( dat )
        sleep(1)
    while i < 30:
        i += 1 
        dat = "18 815000 803000 816000 803500 803500 802500 814000 803000" 
        conn.send( dat )
        sleep(1)


if __name__ == '__main__':
    PARENT_CONN, CHILD_CONN = Pipe()

    PROCESS = Process( target=experiment, args=(CHILD_CONN,) )
    PROCESS.start()

    App( PARENT_CONN )

    PROCESS.join()

